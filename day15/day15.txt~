复习：
1.基于TCP协议的编程模型
服务器：
  (1)创建socket,使用socket函数
  (2)准备通信地址，使用结构体类型地址
  (3)绑定socket和通信地址,使用bind函数
  (4)监听,使用listen函数
  (5)响应客户端的连接请求,使用accept函数
  (6)进行通信，使用send()/recv()函数
  (7)关闭socket,使用close函数
客户端：
  (1)创建socket,使用socket函数
  (2)准备通信地址,是服务器的地址
  (3)连接socket和通信地址,使用connect函数
  (4)进行通信,使用send()/recv()函数
  (5)关闭socket,使用close函数

2.TCP协议和UDP协议的比较
  TCP - 全程保持连接，服务器压力比较大,保证数据的正确性和完整性
  UDP - 不需要全程保持连接，服务器压力小,不保证数据的正确性和完整性

3.基于UDP协议的编程模型
服务器：
   (1)创建socket,使用socket函数
   (2)准备通信地址,使用结构体类型
   (3)绑定socket和通信地址,使用bind函数
   (4)进行通信,使用sendto()/recvfrom()函数
   (5)关闭socket,使用close函数
客户端：
   (1)创建socket,使用socket函数
   (2)准备通信地址,服务器的地址
   (3)进行通信,使用sendto()/recvfrom()函数
   (4)关闭socket,使用close函数
------------------------------------------------
今天内容：
   (1)多线程的基本操作
   (2)多线程的同步问题

1.多线程的基本操作
1.1 基本概念
   线程 - 隶属于进程,是进程内部的程序流,目前主流的操作系统支持多进程，而在每一个进程的内部，又可以支持多线程
   进程是重量级的，每个进程都需要独立的内存空间，所以新建进程对于系统中的资源消耗比较大;而线程是轻量级的，线程共享所在进程的内存资源等,但是每一个线程会需要一个很小的独立的栈区
 
1.2 线程的创建
(1)pthread_create函数
    #include <pthread.h>
    int pthread_create(pthread_t *thread, const
 pthread_attr_t *attr,void *(*start_routine) (
void *), void *arg);
第一个参数：指针变量，存储线程的ID
第二个参数：线程的属性，一般给NULL即可
第三个参数：函数指针，表示新线程指定的功能函数
第四个参数：用于作为第三个参数的实参
返回值：成功返回0，失败返回错误编号
函数功能：主要用于在调用的进程中启动新的线程

注意：
   a.编译链接时加选项： -pthread
   b.在同一个进程内部可以启动新线程，其中新线程叫做子线程，原来的线程叫做主线程，进程中的多个线程之间相互独立又相互影响，当主线程结束时，进程结束，而进程一旦结束，进程中的所有线程都会结束

(2)pthread_self函数
   #include <pthread.h>
   pthread_t pthread_self(void);
函数功能：
   主要用于获取当前正在调用线程的ID

练习：
   在main函数中使用malloc函数申请一个int类型大小的内存空间，并且进行初始化作为圆形的半径,启动一个新的线程，把半径传递给线程处理函数，计算圆形的面积和周长并且打印出来
   面积 = 3.14 * r * r;
   周长 = 2 * 3.14 * r;

1.3 线程的等待和分离
(1)pthread_join函数
   #include <pthread.h>
   int pthread_join(pthread_t thread, void **r
etval);
第一个参数：线程的ID
第二个参数：二级指针
  将目标线程的退出状态信息拷贝到*retval指向的位置
函数功能：
  主要用于等待指定的线程终止，并且获取退出状态信息

练习：
   启动一个新线程，在线程处理函数中计算1~100之间的和存储到一个变量sum中，然后在线程处理函数中返回sum变量的地址,主线程等待并且打印最后的结果

练习：
   启动一个新线程，在线程处理函数中打印1~20之间的数,然后主线程等待子线程结束后，也打印1~20之间的数

(2)pthread_detach函数
   #include <pthread.h>
   int pthread_detach(pthread_t thread);
函数功能：
   主要用于将参数指定的线程标记为分离状态，分离状态的线程结束时，会自动释放资源给系统，不需要其他线程的等待/加入

建议：
   启动线程之后,要么设置为分离状态，要么设置为等待/加入的状态

1.4 线程的终止和取消
(1)pthread_exit函数
   #include <pthread.h>
   void pthread_exit(void *retval);
函数功能：
   主要用于终止当前正在运行的线程,通过参数返回当前线程的退出状态，该退出状态被会同一个进程中的其他线程通过调用pthread_join函数进行获取

   exit()/_exit()/_Exit() - 终止当前进程,进程中所有的线程也就随着进程终止

(2)pthread_cancel函数
   #include <pthread.h>
   int pthread_cancel(pthread_t thread);
函数功能：
   主要用于给参数指定的线程发送取消的请求,是否被取消以及何时被取消取决于两个属性：state 和 type

   #include <pthread.h>
   int pthread_setcancelstate(int state, int *oldstate);
第一个参数：设置线程的取消状态,新状态
   PTHREAD_CANCEL_ENABLE - 允许被取消(默认状态)
   PTHREAD_CANCEL_DISABLE - 不允许被取消
第二个参数：用于带出线程之前的旧状态，可以给NULL   
函数功能：
   主要用于设置线程的取消状态,也就是是否允许被取消

   int pthread_setcanceltype(int type, int *oldtype);
第一个参数：设置新的取消类型
    PTHREAD_CANCEL_DEFERRED - 延迟取消(默认类型)
    PTHREAD_CANCEL_ASYNCHRONOUS - 立即取消
第二个参数：获取旧类型,可以给NULL
函数功能：
   主要用于设置线程的取消类型，也就是何时被取消

2.线程的同步问题
2.1 基本概念
   多线程之间共享进程中的资源，当多个线程同时访问进程中的共享资源时，可能引发数据的混乱，为了避免数据的混乱和不一致性，则需要将多个线程进行协调，而线程之间的协调和通信叫做线程的同步问题

2.2 实现线程同步的基本思想
   让多线程分别串行访问共享资源，而不是并行

2.3 使用互斥量(互斥锁)实现线程同步的基本流程
(1)定义互斥量
   pthread_mutex_t mutex;
(2)初始化互斥量
   pthread_mutex_init(&mutex,NULL);
(3)使用互斥量对共享资源的访问进行加锁
   pthread_mutex_lock(&mutex);
(4)访问共享资源
(5)使用互斥量对共享资源的访问进行解锁
   pthread_mutex_unlock(&mutex);
(6)如果不再使用，则销毁互斥量
   pthread_mutex_destroy(&mutex);

2.4 使用信号量来实现线程的同步问题
(1)基本概念
   信号量 - 本质就是一个计数器，主要用于控制同时访问共享资源的进程数/线程数
   当信号量的值为1时，效果等同于互斥量

(2)使用信号量的基本流程
  #include <semaphore.h>
a.定义信号量
  sem_t sem;
b.初始化信号量
  sem_init(&sem,0,最大值);
  => 0表示该信号量主要用于控制一个进程中的线程数
  => 非0表示该信号量主要用于控制进程的个数
c.获取信号量(信号量减1)
  sem_wait(&sem);
d.使用共享资源
e.释放信号量(信号量加1)
  sem_post(&sem);
f.如果不再使用，则销毁信号量
  sem_destroy(&sem);

2.5 使用条件变量实现线程的同步问题
  生产者-消费者模型
  (在以后DMS项目中进行讲解)

3.综合项目
3.1 项目名称
   基于TCP协议模型的聊天室
3.2 项目功能
   支持最多100人同时在线聊天，要求每个客户端登陆时需要输入昵称，然后发送任意想说的内容
3.3 项目的架构和分析
   采用C/S架构进行设计
(1)服务器
   a.基于TCP通信模型的7步进行编码
   b.实现不断地响应客户端的连接请求，使用无限循环
   c.采用多线程处理同时在线的客户端,使用
     pthread_create函数
   d.实现对每一个客户端可以进行不断的通信,无限循环
   e.对每一次接收到的数据都转发给所有的客户端
   f.每一个连接上来客户端的描述符都保存到一个数组中
     ,然后遍历数组中的每一个描述符，实现群发效果
   g.当客户端发来"bye"时，表示客户端已下线,终止响应
     该客户端的线程，调用pthread_exit()函数
   h.当客户端下线时，需要特殊处理，避免群发数据时，
     给无效的客户端发送消息,对应的fd置为-1

(2)客户端
   a.基于TCP通信模型的5步走
   b.采用多线程将接受消息和发送消息的功能进行分离

3.4 项目要求
(1)要求使用多文件结构编写，支持Makefile文件
(2)要求实现基本的文字聊天，考虑实现文件的传输
(3)考虑使用网络编程和多线程重构银行账户管理系统

   




   









   














































